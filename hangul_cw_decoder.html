<!DOCType HTML>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:fb="http://ogp.me/ns/fb#" manifest="cache.manifest">
<head>
<meta http-equiv="content-type" content="text/html;charset=UTF-8" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name=viewport content='width=900' />
<title>한글 CW 해독기</title>
<script src="hangul_for_cw.js"></script>
<style>
body {
    background-color: white ;
    font-family: 'Helvetica', 'sans serif';
    font-size: large;
}
#page {
    width: 90%;
    margin-left: auto;
    margin-right: auto;
    padding: 1em;
}
p {
    padding: 4px;
    background: white;
    color: black;
}
input {
    padding: 4px;
    border: 1px solid lightsalmon;
    transition: box-shadow 0.3s;
    background: lightyellow;
    border-radius: 5px;
    color: black;
    font-family: 'Helvetica', 'sans serif';
    font-size: large;
}
input:focus {
    border: 1px solid teal;
    box-shadow: 0 0 5px 1px powderblue;
}
button {
    color: black;
    font-family: 'Helvetica', 'sans serif';
    font-size: large;
    font-weight: bold;
}
#start {
    color: blue;
}
#stop {
    color: red;
}
#freq {
    width: 3em;
}
#speed {
    width: 3em;
}
textarea {
    width : 100%;
    height : auto;
    padding: 10px;
    border: 1px solid lightsalmon;
    transition: box-shadow 0.3s;
    background: lightyellow;
    border-radius: 5px;
    color: black;
    font-family: 'Helvetica', 'sans serif';
    font-size: x-large;
    font-weight: bold;
    line-height: 1.5;
}
.hidden_sample {
    display : none;
}
#counter {
    float: right;
}
.font_medium {
    font-size : medium;
}
.setting {
    line-height: 2;
}
.setting_bold {
    font-weight: 600;
}
.setting_group {
    padding: 4px 0px 4px 10px;
    margin-right: 10px;
    border: 1px dotted teal;
    white-space: nowrap;
}
.setting_group_2 {
    margin-right: 10px;
    white-space: nowrap;
}
.log_container {
    width : 100%;
    height : 24em;
    overflow-y: auto;
    padding: 10px;
    border: 1px solid lightsalmon;
    transition: box-shadow 0.3s;
    background: lightyellow;
    border-radius: 5px;
    color: black;
    font-family: 'Helvetica', 'sans serif';
    font-size: x-large;
    font-weight: bold;
    line-height: 1.5;
}
.log_container_ditdah {
    width : 100%;
    height : 16px;
    overflow: hidden;
    padding: 10px;
    border: 1px solid lightsalmon;
    transition: box-shadow 0.3s;
    background: lightyellow;
    border-radius: 5px;
    color: black;
    font-family: 'monospace';
    font-size: small;
    display: block;
    white-space: nowrap;
}
#ditdah_log {
    height:10px;
    float: right;
}
.ditdah_bar {
    background: green;
    height: 10px;
    display: inline-block;
}
.ditdah_gap {
    height: 10px;
    display: inline-block;
}
.font_x-large {
    font-size : x-large;
}
.prevent_wrap {
    white-space: nowrap;
}
::selection {
    background-color: rgba(255, 0, 0, 0.5);
}
.strikethrough {
    text-decoration: line-through;
}
#agc_indicator {
    color: red;
    font-weight: bold;
    animation: blinker 1s linear infinite;
    display: none;
}
@keyframes blinker {
  50% {
    opacity: 0;
  }
}
</style>
</head>
<body><div id="page">
<p>
<h2>한글 CW 해독기 by DS1TZE</h2>
</p>
<p class="setting">
<span class="setting_group_2">
<span class="setting_bold">Signal Speed</span> : <input type="number" id="speed" value="20" size="2" min="5" max="50" /> wpm
</span>
<span class="setting_group">
<label><input type="checkbox" id="hangul" /> Decode hangul</label>
<label><input type="checkbox" id="extra_gap" disabled /> Allow extra gap</label>&nbsp;
</span>
<span class="setting_group_2">
<button id="start">START</button>
<button id="stop">STOP</button>
<button id="clear">CLEAR</button>
</span>
<span class="setting_group">
<label><input type="checkbox" id="record" /> Record screen</label>&nbsp;
<a id="download_link"></a>&nbsp;
</span>
<span id="agc_indicator">AGC [reason]</span>
<br />
Android : Only FireFox. iOS/Mac/PC : Chrome recommended. (FireFox, Safari also OK)
</p>
<p class="log_container_ditdah"><span id="ditdah_log"></span></p>
<p class="log_container"><span id="decoded_log"></span></p>
<p>
    <h3>Intro.</h3><br />
    안녕하세요. DS1TZE 입니다.<br /><br />
    위 프로그램은 한글 CW 해독기 겸 타건 연습기입니다.<br />
    핸드폰이나 노트북 컴퓨터 등 마이크가 있는 장비의 웹브라우저를 통해 이용하면 됩니다.<br />
    리그 앞에 휴대폰이나 컴퓨터 마이크를 둔 후 Start 버튼을 누르기만 하면 대부분 됩니다. Speed는 여유 오차가 넉넉합니다.<br />
    AGC 로직을 갖추고 있어 Start 버튼을 누른 후 몇 초 동안과 신호가 들어오는 동안 주기적으로 로직이 동작하여 부호의 길이와 갭 파악이 점차 정확해집니다.<br />
    만약 주파수를 변경해서 새롭게 선국했거나 신호를 보내오는 상대가 달라지면 Start 버튼을 한 번씩 눌러주는 것이 좋습니다.<br />
    DitDah Bar 영역에선 파악한 신호를 막대로 보여줍니다. 막대가 보이지 않는다면 마이크와 리그 스피커의 간격을 조금 좁히고 리그의 볼륨을 조절해 막대가 나타나도록 한 후 Start 버튼을 다시 눌러주면 됩니다.<br />
    <a href="hangul_cw_trainer.html" target="_blank">[한글 CW 청취 연습기]</a> 혹은 PC용 SDR, 유투브 영상 등의 신호를 해독해보려면, 컴퓨터의 녹음(소리 입력) 장치를 Stereo Mix* 로 선택하고 볼륨을 20~30% 수준으로 세팅하면 됩니다.<br />
    휴대폰에서는, 파이어폭스나 크롬 브라우저를 이용해, 탭 하나엔 해독기를 열어두고 다른 탭엔 청취 연습기를 열어서 소리는 내면서 해독을 시도해봐도 잘 됩니다.<br />
    많은 활용 바라며, 기능 제안은 온에어에서 말씀해주시기 바랍니다.<br />
    ※ 소리 입력 장치 선택 : Windows 설정 -> 시스템 -> 소리. 만약 입력장치 목록에 Stereo Mix 없으면, [사운드 제어판] -> [녹음]탭에서 Stereo Mix 활성화 후 입력 장치 선택.
    <br />
    <br />

    <h3>Links</h3>
    Hangul CW Trainer - <a href="hangul_cw_trainer.html" target="_blank">http://shingiru.github.io/hangul_cw_trainer.html</a><br />
    위 라이브러리가 사용하는 기술인 Web Audio API - <a href="https://webaudio.github.io/web-audio-api/" target="_blank">https://webaudio.github.io/web-audio-api/<a/><br />
    한글 자모 합성 Javascipt 라이브러리* - <a href="https://github.com/e-/Hangul.js/" target="_blank">https://github.com/e-/Hangul.js/</a><br />
    ※ 한글 CW는 26개 부호만 사용하기 때문에, 라이브러리를 많이 수정해 "ㅖ"와 "ㅒ"는 각각 "ㅕ" + "ㅣ" 및 "ㅑ" + "ㅣ" 를 합성하도록 하고, 같은 홑낱자로 연속 출현도 경우에 따라 겹낱자도 합성하도록 했습니다.<br />
    <br />
    <br />

    <h3>DE DS1TZE - <a href="https://www.qrz.com/db/DS1TZE" target="_blank" class="font_medium">https://www.qrz.com/db/DS1TZE</a>
    <span id="counter">
        <a href="https://hits.seeyoufarm.com"><img src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fshingiru.github.io%2Fhangul_cw_decoder.html&count_bg=%2379C83D&title_bg=%23555555&icon=&icon_color=%23E7E7E7&title=hits&edge_flat=false"/></a>
    </span>
    </h3>

</p>
<p class="font_medium">
<h3>Change Log</h3>
2022.08.29. "Allow extra gap" added. Korean callsigns prevented from decoding.<br />
2022.08.26. Screen recording added.<br />
2022.08.22. Android Support.<br />
2022.08.21. Tone frequency and Mic gain setting removed, set automatically.<br />
2022.08.20. DitDah Bar and Setting Guide added.<br />
2022.08.19. First version of Hangul CW Decoder.<br />
</p>
</div>
</body>
<script type="text/javascript">
var audioInitialized = videoInitialized = false, ac, gain, analyser, lastDitdah = false, ditdahAmount = 0, gapAmount = 0, maxGapReached = false, binCount = 256;

var wpm = document.querySelector("#speed");
var hangul = document.querySelector("#hangul");
var extraGap = document.querySelector("#extra_gap");
var start = document.querySelector("#start");
var stop = document.querySelector("#stop");
var clear = document.querySelector("#clear");
var record = document.querySelector("#record");

start.addEventListener("click", async () => {
    stop.click();

    if (record.checked) {
        if (!videoInitialized) {
            var constraints = {
                audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false },
                video: { mediaSource: "screen" }
            };
            navigator.mediaDevices.getDisplayMedia(constraints).then(async (stream) => {
                mediaRecorder = createRecorder(stream);
                mediaRecorder.start(200);
                videoInitialized = true;
            });
        } else {
            mediaRecorder.start(200);
        }
    }

    if (!audioInitialized) {
        ac = new AudioContext();

        var constraints = {
            audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false },
            video: false
        };
        navigator.mediaDevices.getUserMedia(constraints).then(async (stream) => {
            var input = ac.createMediaStreamSource(stream);
            gain = ac.createGain();
            gain.gain.value = 1.0;
            input.connect(gain);

            analyser = ac.createAnalyser();
            analyser.minDecibels = -90;
            analyser.maxDecibels = -30;
            if (isAndroid) analyser.smoothingTimeConstant = 0; // when THRESHOLD is high, this value is not important
            binCount = analyser.frequencyBinCount;
            gain.connect(analyser);
            //analyser.connect(ac.destination); // important! this should be commented out

            doAgc("in Start");
            lastProcessedAt = 0;
            processMorse();

            audioInitialized = true;
        });
    } else {
        if (ac.state != "running") ac.resume();
        doAgc("in Start");
        lastProcessedAt = 0;
        processMorse();
    }
}, false);

var mediaRecorder = null;
function createRecorder(stream) {
    let chunks = [];
    const mr = new MediaRecorder(stream, {mimeType: 'video/webm;codecs=h264'});

    mr.ondataavailable = function(e) {
        if (e.data.size > 0)
            chunks.push(e.data);
    };
    mr.onstop = function() {
        saveFile(chunks);
        chunks = [];
    }
    mr.onstart = function() {
        var anchor = document.querySelector("#download_link");
        if (anchor.childNodes.length > 0) anchor.removeChild(anchor.firstChild);
    }
    return mr;
}
function saveFile(chunks) {
    const blob = new Blob(chunks);
    let link = document.createElement("A");
    link.href = URL.createObjectURL(blob);
    link.appendChild(document.createTextNode("[DOWNLOAD]"));
    const filename = (new Date()).toISOString().replace(/[\-\:T]/ig, '').substring(0, 14);
    link.download = filename + ".webm";

    var anchor = document.querySelector("#download_link");
    link.id = anchor.id;
    anchor.parentNode.replaceChild(link, anchor);
    // link.click();
    // URL.revokeOjectURL(blob); // clear from memory
}

var gaps = [], smallGapRepeat = 0, AGC_AGAIN_WHEN_SMALL_GAP_REPEAT_CNT = 2, lastSmallGapCheckStartAt = 0;
function agc(target, gap) {
    gaps.push(gap);
    if (gaps.length == 5) {
        var sum = 0;
        for (var value of gaps) sum += value;
        var avg = sum / gaps.length;
        var diff = 1 + (avg - target) / target;
        diff = Math.min(1.1, Math.max(0.9, diff));
        if (diff > 0.95 && diff < 1.05) {
            gaps = [];
            return;
        }

        var fix = gain.gain.value * diff;
        console.log("[AGC] target gap " + (needToAgc ? "need to be fixed" : "fixed") + " : " + target + ", current gap : " + parseInt(avg) + ", current gain : " + gain.gain.value + ", fix gain : " + fix);
        if (!needToAgc) {
            gain.gain.value = Math.min(1, Math.max(0, fix));

            if (avg > target * 1.5) {
                smallGapRepeat++;
                if (avg > target * 2) smallGapRepeat++;
            } else {
                smallGapRepeat = 0;
            }
            checkAgcNeededAndDo();
            if (avg <= target * 1.5) lastSmallGapCheckStartAt = performance.now();
        }
        gaps = [];
    }
}
var needToAgc = true, gainBottom = 1.0, bottomCheckStartAt = lastPeakAt = lastLongDahCheckStartAt = 0;
var AGC_PEAK_GAIN_DECREASE_AMOUNT = 0.01, AGC_MIN_PEAK_GAIN_CHECK_DURATION = 5000;
var AGC_POLICY = {
    NO_PEAK : { reason : "No Peak", thresholdDit : 100 },
    LONG_DAH : { reason : "Long Dah", thresholdDit : 100 },
    SMALL_GAP : { reason : "Small Gap", thresholdDit : 100 }
}
function doAgc(reason) {
    printDecodedLine(" ");
    needToAgc = true;
    gainBottom = 1.0;
    gain.gain.value = 1.0;
    bottomCheckStartAt = lastPeakAt = lastLongDahCheckStartAt = maxGainRepeat = lastSmallGapCheckStartAt = 0;
    toggleAgcIndicator(true, reason);
}
function try_agc(peak) {
    var now = performance.now();
    if (peak) lastPeakAt = now;

    if (!needToAgc) return;

    if (bottomCheckStartAt != 0 && (now - bottomCheckStartAt) > AGC_MIN_PEAK_GAIN_CHECK_DURATION) { // skip gap agc during first 5 sec
        gain.gain.value = Math.min(1, gainBottom * (isAndroid ? 1 : 1.25));
        console.error("[AGC SET] bottom : " + gainBottom + ", set : " + gain.gain.value);
        needToAgc = false;
        toggleAgcIndicator(false);
        return;
    }

    if (peak) { // when met fist peak, start to calculate minimum gain that can catch peak still, by decreasing small amount of gain
        gainBottom -= AGC_PEAK_GAIN_DECREASE_AMOUNT; // decrease small amount
        gainBottom = Math.max(0.1, gainBottom); // gain minimum
        //console.log("[AGC SET] change gain : " + gain.gain.value + " => " + gainBottom);
        gain.gain.value = gainBottom;
        if (bottomCheckStartAt == 0) bottomCheckStartAt = now;
    }
}
function checkAgcNeededAndDo() { // agc again when enough signal not accepted
    if (needToAgc) return; // already in agc process

    var now = performance.now();
    if (lastPeakAt != 0 && (now - lastPeakAt > AGC_POLICY.NO_PEAK.thresholdDit * ditDuration)) {
        doAgc(AGC_POLICY.NO_PEAK.reason);
    } else if (lastLongDahCheckStartAt != 0 && (now - lastLongDahCheckStartAt > AGC_POLICY.LONG_DAH.thresholdDit * ditDuration)) {
        doAgc(AGC_POLICY.LONG_DAH.reason);
    } else if (smallGapRepeat >= AGC_AGAIN_WHEN_SMALL_GAP_REPEAT_CNT && lastSmallGapCheckStartAt != 0 && (now - lastSmallGapCheckStartAt > AGC_POLICY.SMALL_GAP.thresholdDit * ditDuration)) {
        if (!(hangul.checked && extraGap.checked)) doAgc(AGC_POLICY.SMALL_GAP.reason);
    }
}
function toggleAgcIndicator(show, reason) {
    var agcIndicator = document.querySelector("#agc_indicator");
    agcIndicator.replaceChild(document.createTextNode("[AGC] " + reason), agcIndicator.firstChild);
    agcIndicator.style.display = (show ? "inline" : "none");
}

var toneBuffer = null, ditDuration, minDitDuration, maxDitDuration, letterGapDuration, toneStart, toneEnd, lastProcessedAt = 0, timerId;
var DITDAH_THRESHOLD = 227;//parseInt(256 * 0.98); // 227 is magic number
var ua = navigator.userAgent.toLowerCase();
var isIOS = (ua.indexOf("iphone") > -1 || ua.indexOf("ipad") > -1 || ua.indexOf("ipod") > -1);
var isAndroid = ua.indexOf("android") > -1;
if (isAndroid) DITDAH_THRESHOLD = parseInt(256 * 0.5);
var firstDitDahStarted = false;
var agcElapsed = 0;
function processMorse() {
    if (toneBuffer == null) toneBuffer = new Uint8Array(binCount);
    ditDuration = parseInt(1.2 / parseInt(wpm.value) * 1000); // from wikipedia
    minDitDuration = parseInt(ditDuration * 0.1);
    maxDitDuration = parseInt(ditDuration * 2.0);
    minDitdahGap = parseInt(ditDuration * 0.5);
    maxDitdahGap = parseInt(ditDuration * 2.0);
    letterGapDuration = ditDuration * 6;
    if (hangul.checked && extraGap.checked) {
        letterGapDuration *= 3;
        maxDitDuration = parseInt(ditDuration * 2.5);
        maxDitdahGap = parseInt(ditDuration * 3.0);
    }
    var bucketSize = 44100 / 2 / binCount;
    toneStart = Math.max(parseInt(400 / bucketSize), 1);
    toneEnd = Math.min(parseInt(800 / bucketSize), binCount - 1);

    analyser.getByteFrequencyData(toneBuffer);
    var now = performance.now();
    if (lastProcessedAt == 0) lastProcessedAt = now;
    var frameDuration = now - lastProcessedAt; //parseInt(now - lastProcessedAt);
    lastProcessedAt = now;

    var buffer = toneBuffer.slice(0).slice(toneStart, toneEnd);
    var peak = 0, peakIndex = 0;
    for (var i = 0; i < buffer.length; i++) {
        if (peak < buffer[i]) {
            peak = buffer[i];
            peakIndex = i;
        }
    }
    //console.log(buffer.join(","));

    var ditdah = (peak > DITDAH_THRESHOLD);

    var n = buffer.length;
    var mean = buffer.reduce((a, b) => a + b) / n;
    var standardDeviation = Math.sqrt(buffer.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / n);
    var snr = mean / standardDeviation;
    //console.log("ditdah : " + ditdah + ", μ : " + mean + ", σ : " + standardDeviation + ", SNR : " + snr);

    //if (ditdah) console.log("ditdah : " + ditdah + ", peak index : " + peakIndex + ", peak - 1 : " + buffer[peakIndex - 1] + ", peak : " + buffer[peakIndex] + ", peak + 1 : " + buffer[peakIndex + 1] + ", frameDuration : " + frameDuration);
    if (peak > 0) printDitdah(ditdah, frameDuration);

    var peakCount = 0;
    for (var value of buffer)
        if (value > DITDAH_THRESHOLD)
            peakCount++;

    agcElapsed += frameDuration;
    if (agcElapsed >= 23) { // at least 10ms or 46ms (fft sample size 2048 / 44100)
        if (peak > DITDAH_THRESHOLD * 0.5 && peak < DITDAH_THRESHOLD) {
            try_agc(false);
            checkAgcNeededAndDo();
        } else if (peakCount > 1) { // } else if (peakCount > (isAndroid ? 1 : 2)) {
            try_agc(true);
        }
        agcElapsed = 0;
    }

    if (ditdah) { // TODO : need to determine gap after a few ditdah, not with single gap. Or, after enough gap arrived.
        if (lastDitdah == false) {
            if (gapAmount < minDitdahGap) { // noise
                console.log("GAP NOISE, " + gapAmount);
            } else if (gapAmount < maxDitdahGap) { // inter-dit-dah
                console.log("INTER-DITDAH GAP, " + gapAmount);
                agc(ditDuration, parseInt(gapAmount));
                gapAmount = 0;
            } else {
                console.log("WORD GAP, " + gapAmount);
                makeCharacter(hangul.checked);
                if (gapAmount > letterGapDuration) {
                    flushCharacter(hangul.checked);
                    printDecodedChar(" ");
                }
                gapAmount = 0;
            }
        }
        ditdahAmount += frameDuration;
        maxGapReached = false;

    } else {
        if (lastDitdah == true) {
            if (ditdahAmount < minDitDuration) { // noise
                console.log("DITDAH NOISE, " + ditdahAmount);
            } else if (ditdahAmount < maxDitDuration) { // dit
                console.log("DIT, " + ditdahAmount);
                addToLetter(true);
            } else { // dah
                console.log("DAH, " + ditdahAmount);
                addToLetter(false);
                checkAgcNeededAndDo();
            }
        }
        ditdahAmount = 0;
        gapAmount += frameDuration;
        lastLongDahCheckStartAt = now;

        // when enough gapAmount
        if (gapAmount > letterGapDuration) {
            makeCharacter(hangul.checked);
            flushCharacter(hangul.checked);
        }
        if (gapAmount > letterGapDuration * 5 && !maxGapReached) { // 5 or 7
            console.log("MAX GAP, " + gapAmount);
            //makeCharacter(hangul.checked);
            //flushCharacter(hangul.checked);
            printDecodedLine(" ");
            gapAmount = 0;
            maxGapReached = true;
            //console.clear();
        }
    }
    lastDitdah = ditdah;

    timerId = setTimeout(processMorse);
}

var ditdahs = "";
var hangulLetters = [];
var previousLetters = [];
function addToLetter(ditdah) { // ditdat - dit:true, dah:false
    ditdahs += (ditdah ? "." : "-");
}
var HANGUL2ALPHABET = null;
function hangulToAlphabet(letter) {
    if (HANGUL2ALPHABET == null) {
        HANGUL2ALPHABET = {};
        for (var key in HANGUL) {
            HANGUL2ALPHABET[HANGUL[key]] = MORSE[key];
        }
    }
    return HANGUL2ALPHABET[letter];
}
function flushCharacter(makeHangul) {
    if (makeHangul && hangulLetters.length > 0) {
        var characters = Hangul.assemble(hangulLetters);
        if (characters.length == 1) {
            updateDecodedHangul(characters);
        } else { // characters.length == 2
            updateDecodedHangul(characters.charAt(0));
            printDecodedHangul(characters.charAt(1));
        }
        hangulLetters = [];
    }
    previousLetters = [];
}
function makeCharacter(makeHangul) {
    if ("undefined" != typeof MORSE[ditdahs]) {
        var letter = MORSE[ditdahs];
        previousLetters.push(letter);
        if ("undefined" != typeof PROSIGN[letter]) {
            flushCharacter(makeHangul);
            printDecodedChar(PROSIGN[letter]);
        } else {
            if (makeHangul && !isCallsign()) {
                if (hangulLetters.length == 0) {
                    printDecodedChar(letter);
                    if ("undefined" != typeof HANGUL[ditdahs]) {
                        hangulLetters.push(HANGUL[ditdahs]);
                    }
                } else if (hangulLetters.length == 1) { // with current letter, 2 letters
                    if ("undefined" != typeof HANGUL[ditdahs]) {
                        hangulLetters.push(HANGUL[ditdahs]);
                        var characters = Hangul.assemble(hangulLetters);
                        if (characters.length == 1) {
                            updateDecodedHangul(characters);
                        } else {
                            hangulLetters.shift();
                            printDecodedChar(letter);
                        }
                    } else {
                        hangulLetters.shift();
                        printDecodedChar(letter);
                    }
                } else { // with current letter, 3 letters or more
                    if ("undefined" != typeof HANGUL[ditdahs]) {
                        hangulLetters.push(HANGUL[ditdahs]);
                        var characters = Hangul.assemble(hangulLetters);
                        if (characters.length == 1) {
                            updateDecodedHangul(characters);
                        } else { // characters.length == 2
                            updateDecodedHangul(characters.charAt(0));
                            var hangulCharacters = Hangul.disassemble(characters, true);
                            hangulLetters = hangulCharacters[1];
                            printDecodedHangul(characters.charAt(1));
                        }
                    } else {
                        var characters = Hangul.assemble(hangulLetters);
                        if (characters.length == 1) {
                            updateDecodedHangul(characters);
                        } else { // characters.length == 2
                            updateDecodedHangul(characters.charAt(0));
                            printDecodedHangul(characters.charAt(1));
                        }
                        hangulLetters = [];
                        printDecodedChar(letter);
                    }
                }
            } else {
                printDecodedChar(letter);
                if (hangulLetters.length != 0) hangulLetters = [];
            }
        }
    }
    ditdahs = "";
}
function printDecodedHangul(character) {
    if (Hangul.isComplete(character)) printDecodedChar(character);
    else {
        var s = "";
        for (var value of Hangul.disassemble(character)) s += hangulToAlphabet(value);
        printDecodedChar(s);
    }
}
function updateDecodedHangul(character) {
    if (Hangul.isComplete(character)) updateDecodedChar(character);
    else {
        var s = "";
        for (var value of Hangul.disassemble(character)) s += hangulToAlphabet(value);
        updateDecodedChar(s);
    }
}
var KOREA_PREFIX = ["HL", "DS", "6K", "6L", "6M", "D7", "D9"];
function isCallsign() {
    if (previousLetters.length == 0) return false;

    var letters = previousLetters.slice(-(Math.min(6, previousLetters.length))).join(""); // last 5 + argument
    if (letters.length < 3) return false;

    var index = 0;
    for (var i = 0; i < letters.length; i++) {
        code = letters.charCodeAt(i);
        if (!(code > 47 && code < 58) && !(code > 64 && code < 91)) index = i; // callsign is only using alpha-numeric
    }
    letters = letters.substring(index);
    if (letters.length < 3) return false;
    console.log(letters);

    for (var value of KOREA_PREFIX)
        for (var num of [0, 1, 2, 3, 4, 5])
            if (letters.indexOf(value + num) >= 0) return true;

    return false;
}

stop.onclick = function() {
    try { clearTimeout(timerId); }
    catch (e) {}

    if (mediaRecorder != null) mediaRecorder.stop();
}
clear.onclick = function() {
    clearDecodedLog();
    clearDitdah();
}
record.onchange = function() {
    if (isAndroid || isIOS) {
        alert("Mobile devices don't support screen capture.");
        record.checked = false;
    }
}
wpm.onchange = function() {
    window.localStorage.setItem('wpm', wpm.value);
}
hangul.onchange = function() {
    window.localStorage.setItem('hangul', hangul.checked);
    extraGap.disabled = !(hangul.checked);
}
extraGap.onchange = function() {
    window.localStorage.setItem('extraGap', extraGap.checked);
}
window.addEventListener('DOMContentLoaded', function() {
    try {
        if (window.localStorage.getItem('wpm')) wpm.value = parseInt(window.localStorage.getItem('wpm'));
        if (window.localStorage.getItem('hangul')) hangul.checked = window.localStorage.getItem('hangul') == 'true';
        if (hangul.checked) extraGap.disabled = false;
        if (window.localStorage.getItem('extraGap')) extraGap.checked = window.localStorage.getItem('extraGap') == 'true';
    } catch (e) {}
}, true);

var decodedLog = document.querySelector("#decoded_log");
var textNode = null;
function printDecodedChar(s) {
    if (needToAgc) s = "";
    textNode = document.createTextNode(s);
    decodedLog.appendChild(textNode);
    if (!isAndroid && !isIOS) decodedLog.scrollIntoView(false);
}
function updateDecodedChar(s) {
    if (needToAgc) s = "";
    if (textNode) textNode.textContent = s;
    else printDecodedChar(s);
    if (!isAndroid && !isIOS) decodedLog.scrollIntoView(false);
}
function printDecodedLine(s) {
    var el = document.createElement("DIV");
    decodedLog.appendChild(el);
    var tn = document.createTextNode(s);
    el.appendChild(tn);
}
function clearDecodedLog() {
    decodedLog.textContent = "";
    printDecodedChar("");
}

var ditdahLog = document.querySelector("#ditdah_log");
var lastDitdahLog = false, lastWidth = 0;
function printDitdah(ditdah, len) {
    if (needToAgc) ditdah = false;
    if (ditdah == lastDitdahLog && ditdahLog.childNodes.length > 0 && lastWidth < 256) {
        var span = ditdahLog.lastChild;
        lastWidth += len;
        span.style.width = (parseInt(lastWidth) >> 3) + "px";
        return;
    }
    var span = document.createElement("SPAN");
    span.className = ditdah ? "ditdah_bar" : "ditdah_gap";
    span.style.width = parseInt(len >> 3) + "px";
    ditdahLog.appendChild(span);
    if (ditdahLog.childNodes.length > 256) ditdahLog.removeChild(ditdahLog.firstChild);
    lastDitdahLog = ditdah;
    lastWidth = len;
}
function clearDitdah() {
    var len = ditdahLog.childNodes.length;
    for (var i = 0; i < len; i++) ditdahLog.removeChild(ditdahLog.firstChild);

    lastProcessedAt = 0;
}

MORSE = {
    ".-": "A",
    "-...": "B",
    "-.-.": "C",
    "-..": "D",
    ".": "E",
    "..-.": "F",
    "--.": "G",
    "....": "H",
    "..": "I",
    ".---": "J",
    "-.-": "K",
    ".-..": "L",
    "--": "M",
    "-.": "N",
    "---": "O",
    ".--.": "P",
    "--.-": "Q",
    ".-.": "R",
    "...": "S",
    "-": "T",
    "..-": "U",
    "...-": "V",
    ".--": "W",
    "-..-": "X",
    "-.--": "Y",
    "--..": "Z",

    ".----": "1",
    "..---": "2",
    "...--": "3",
    "....-": "4",
    ".....": "5",
    "-....": "6",
    "--...": "7",
    "---..": "8",
    "----.": "9",
    "-----": "0",

    ".-.-.-": ".",
    "--..--": ",",
    "..--..": "?",
    "-..-.": "/",
    ".-.-.": "+",
    "-....-": "-",
    "-...-": "=",
    "---...": ":",
    "-.-.-.": ";",
    "-.--.": "(",
    "-.--.-": ")",
    ".----.": "'",
    ".-..-.": "\"",
    ".--.-.": "@",

    // for prosign
    ".-...": "&",
    "...-.": "Ŝ",
    // non-standard
    "-...-.-": "[",
    "...-.-": "]",
    "-.-.-": "^",
    "........": "※"
};

HANGUL = {
    ".-..": "ㄱ",
    "..-.": "ㄴ",
    "-...": "ㄷ",
    "...-": "ㄹ",
    "--": "ㅁ",
    ".--": "ㅂ",
    "--.": "ㅅ",
    "-.-": "ㅇ",
    ".--.": "ㅈ",
    "-.-.": "ㅊ",
    "-..-": "ㅋ",
    "--..": "ㅌ",
    "---": "ㅍ",
    ".---": "ㅎ",
    ".": "ㅏ",
    "..": "ㅑ",
    "-": "ㅓ",
    "...": "ㅕ",
    ".-": "ㅗ",
    "-.": "ㅛ",
    "....": "ㅜ",
    ".-.": "ㅠ",
    "-..": "ㅡ",
    "..-": "ㅣ",
    "-.--": "ㅔ",
    "--.-": "ㅐ"
};

PROSIGN = {
    "+": "<AR>",
    "(": "<KN>",
    "&": "<AS>",
    "=": "<BT>",
    "Ŝ": "<SN>",
    // non-standard
    "[": "<BK>",
    "]": "<SK>",
    "]": "<VA>",
    "^": "<KA>",
    "※": "<HH>"
};
</script>

</html>
